# Consensus
A group project with Amber Strange and Max Westerkam from Duke's CS310 (Operating and Distributed Systems). Follows Raft's consensus algorithm, implementing leader election and log repair

## How it works
Consensus solves the problem of replicated state machine (RSM) failure in distributed systems. RSMs are represented by the three classes: FollowerMode, CandidateMode, and LeaderMode. RSMs maintain 3 parts of a persistent state: the current term, the candidate for which the server voted for, and the server log. Remote procedure calls (RPCs), remoteAppendEntries and remoteRequestVotes, are made in the RaftMode class. RSMs respond to these with their appendEntries and requestVote methods, respectively. The RaftMode class stores raft responses.  The algorithm can be split into two main parts: leader election and log repair. 

### Leader Election
Every RSM begins as a follower. To transition from a follower to a candidate, each follower has an election timer, a random number between 150 and 300 ms. However, a follower will remain a follower, if it receives an empty remoteAppendEntries or remoteRequestVotes RPC from a server that has a higher term or has a more up to date log. Followers' election timeouts are prevented by empty appendEntries calls from the leader. Upon becoming a candidate, the candidate increments its current term, and sends out a remoteRequestVotes to other RSMs. Candidates will also step down if they receive a RPCs from servers with a higher term or more up to date log. While in candidate mode, a candidate checks to see if it received a majority of votes from other servers by via a polling timer. If a candidate does not receive a majority, it restarts its election timer and increments its term, thereby beginning a new election. If it does have a majority, it transitions to leader mode. Once in leader mode, a leader will step down if another server responds with a higher term. When RSMs switch states, the program prints "S#.#: switched to ____ mode", where the #'s represent the server number and their term number. 

### Log repair
To ensure fault protectoin, log entries must be rewritten throughout the course of the program. Leaders are the only RSMs that can ovewrite logs, and followers are the RSMs that can have their logs overwritten. In log repair, the leader searches for the first entry in the follower's log that matches its own. Then, the leader copies its log starting from that matching index over to the follower. In this project, log entries are represented as files, each line representing a log entry, with two integers: term and action. Ideally, throughout recurring failures, RSMs' logs converge toward the end. 

The project can be tested by running the runtest.sh with any of the test.txt files in this repo. Here is an example: 'bin/runtest.sh 10 tests/sampletest.txt'. The second argument specifies the number of RSMs. 
